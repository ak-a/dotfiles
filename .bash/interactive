#!/bin/bash
#
# this is only sourced if we are interactive, but will be sourced before other stuff
# good place to put setup and environment stuff
#
[[ -f /etc/bash_completion && $_bash_completion_done != $$ ]] && {
    source /etc/bash_completion
    for c in /home/linuxbrew/.linuxbrew/etc/bash_completion.d/*
    do
        [[ -r $c ]] && source $c
    done
}
_bash_completion_done=$$

declare -A _completion_commands=( 
    argocd     "completion  bash"  
    gcloud     "completion  bash"  
    gh         "completion  -s     bash"
    helm       "completion  bash"  
    k9sectl    "completion  bash"  
    kubectl    "completion  bash"  
    kustomize  "completion  bash"  
)

for c in ${!_completion_commands[*]}
do
    complete | egrep -q -e "-F \w+ $c\$" && continue
    _c_cache=~/.bash/completion-$c
    [[ -s $_c_cache ]] || {
        $c ${_completion_commands[$c]} 2>/dev/null > $_c_cache
    }
    source $_c_cache
    _completion_commands_done[$c]=1
done

type -t kubectl &>/dev/null && {
    alias k=kubectl
    complete -o default -F __start_kubectl k
}
type -t kubectx &>/dev/null && alias kx=kubectx
type -t terraform &>/dev/null && {
    complete -C $(type -p terraform) terraform
    alias tf=terraform
    complete -C $(type -p terraform) tf
}
type -t terragrunt &>/dev/null && alias tg=terragrunt

[[ -n $HOMEBREW_PREFIX && -r $HOMEBREW_PREFIX/etc/bash_completion ]] && \
    source $HOMEBREW_PREFIX/etc/bash_completion

# Environment setup
# #################
# I rule over all the other PATH bits
PrependPath $HOME/bin

# to avoid cm issues on centOS 5
export EDITOR=vim

#

# Aliases
# #######

alias grep='grep --color'                     # show differences in colour
#alias ls='ls -h --color=tty'                 # classify files in colour
alias mux=tmuxinator
type -t jless &>/dev/null && alias yless="jless --yaml"

# Functions
# #########

function settitle() { echo -n "^[]2;$*^G^[]1;$*^G"; }
readarray -t _git_emojis < ~/.git-emoji
function nwtb() {

    local jira_ticket git_emoji
    [[ $1 =~ ^([A-Z]{2,}-[0-9]+)(-.*)? ]] || { echo "nwtb: '$1' doesn't start with a JIRA ticket number XX*-dd*" ; return 2; }
    jira_ticket=${BASH_REMATCH[1]}

    cd $(git worktree list 2>/dev/null | head -1 | cut -d' ' -f1) || return 1
    git fetch \
        && cd master \
        && git pull \
        && cd .. \
    && git worktree add -b $1 $1 || return $?
    cd $1 || return $?

    # now we setup the wt branch
    pre-commit install
    git push --set-upstream origin $1

    # choose what this is commit type
    if type -t gum &>/dev/null; then
        # use gum as preferred option
        git_emoji=$(gum choose --height 20 "${_git_emojis[@]}" | cut -d' ' -f1)
    else
        select git_emoji in "${_git_emojis[@]}"
        do
            break;
        done
    fi
    cat > .gitmessage <<GITMESSAGE
$git_emoji $jira_ticket ####SUBJECT WHAT####

BODY#####WHY
GITMESSAGE
    git config commit.template .gitmessage
}

export SHELLCHECK_OPTS="-e SC2086 -e SC2046"

gofind() { # [dir] [test]
    local testarg
    testarg=true
    [[ -z $2 ]] && testarg='! -name "*_test.go"'

    find ${1:-.} \( -name "*.go" -a $testarg \) -print0
}

gogrep() {
    gofind $2 $3 | xargs -0 grep $4 -e "$1"
}

ygrep() { # grep in yaml
    grep -r ${2:.} --include "*.yaml" $3 -e "$1" 
}

function urldecode() {
    : "${*//+/ }"
    echo -e "${_//%/\\x}"
}
urlencode() {
    # urlencode <string>
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c"
        esac
    done
}

# add any clean-up etc here
bash_trap_exit() {
    [[ $(type -t shell_history_write_all) == function ]] &&
        shell_history_write_all
    rm -f /tmp/bashtrace.$$.txt /tmp/bashtrace.$$.txt
}

trap -- bash_trap_exit EXIT


